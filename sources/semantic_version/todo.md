# TDDによるセマンティックバージョニング実装 Todoリスト

このドキュメントは、[セマンティック バージョニング 2.0.0](https://semver.org/lang/ja/)仕様をTDDのアプローチで実装するためのステップを定義します。

## フェーズ1: 基本的なバージョンのパースと表示

### ステップ1: プロジェクトのセットアップ
- [x] `cargo new semantic_version`でプロジェクトを作成する
- [x] `src/lib.rs`に基本的な構造体`Version`を定義する
  ```rust
  #[derive(Debug)]
  struct Version {
      major: u64,
      minor: u64,
      patch: u64,
  }
  ```

### ステップ2: 単純なバージョン文字列のパース (`MAJOR.MINOR.PATCH`)
- [x] **テスト**: `"1.2.3"`のような有効な文字列をパースできることを確認するテストを書く。最初はコンパイルエラーになる。
- [x] **実装**: `Version`構造体に`FromStr`トレイトを実装し、テストをパスさせる。
- [x] **リファクタリング**: コードをクリーンにする。

### ステップ3: 不正なバージョ��文字列のパース
- [ ] **テスト**: `"1.2"`, `"1"`, `"a.b.c"`のような不正な形式の文字列でエラーが返ることを確認するテストを追加する。
- [ ] **実装**: パースロジックを修正し、`Result<Version, Error>`を返すようにして、テストをパスさせる。
- [ ] **リファクタリング**: エラーハンドリングを改善する。

### ステップ4: `Display`トレイトの実装
- [ ] **テスト**: パースした`Version`オブジェクトを`to_string()`で文字列に変換し、元の文字列と一致することを確認するテストを書く。
- [ ] **実装**: `Display`トレイトを実装して、テストをパスさせる。
- [ ] **リファクタリング**: コードをクリーンにする。

## フェーズ2: バージョンの比較

### ステップ5: 等価性の比較 (`PartialEq`, `Eq`)
- [ ] **テスト**: `Version::from_str("1.2.3").unwrap() == Version::from_str("1.2.3").unwrap()`が`true`になるテストを書く。
- [ ] **実装**: `Version`構造体に`PartialEq`と`Eq`を`#[derive]`で実装する。
- [ ] **リファクタリング**: 不要。

### ステップ6: 順序の比較 (`PartialOrd`, `Ord`)
- [ ] **テスト**: 以下の順序関係が正しく評価されるテストを書く��
  - `1.0.0 < 2.0.0`
  - `1.1.0 > 1.0.0`
  - `1.1.1 > 1.1.0`
- [ ] **実装**: `Version`構造体に`PartialOrd`と`Ord`を実装し、`major`, `minor`, `patch`の順で比較するロジックを書く。
- [ ] **リファクタリング**: 比較ロジックを明確にする。

## フェーズ3: プレリリース識別子のサポート

### ステップ7: プレリリース識別子を持つバージョンのパース
- [ ] **構造体変更**: `Version`構造体にプレリリース識別子を格納するフィールドを追加する。
  ```rust
  // 例
  pre: Vec<Identifier>,
  
  enum Identifier {
      Numeric(u64),
      AlphaNumeric(String),
  }
  ```
- [ ] **テスト**: `"1.0.0-alpha"`, `"1.0.0-alpha.1"`, `"1.0.0-0.3.7"`のような文字列をパースできるテストを書く。
- [ ] **実装**: `FromStr`の実装を拡張し、`-`以降のプレリリース部分をパースできるようにする。
- [ ] **リファクタリング**: パースロジックを整理する。

### ステップ8: プレリリース識別子を持つバージョンの比較
- [ ] **テスト**: SemVer仕様に基づいたプレリリースバージョンの比較テストを追加する。
  - `1.0.0-alpha < 1.0.0`
  - `1.0.0-alpha < 1.0.0-alpha.1`
  - `1.0.0-alpha.1 < 1.0.0-alpha.beta`
  - `1.0.0-alpha.beta < 1.0.0-beta`
  - `1.0.0-beta < 1.0.0-beta.2`
  - `1.0.0-beta.2 < 1.0.0-beta.11`
  - `1.0.0-beta.11 < 1.0.0-rc.1`
  - `1.0.0-rc.1 < 1.0.0`
- [ ] **実装**: `Ord`の実装を修正し、プレリリース識別子の比較ロジックを追加する。
- [ ] **リファクタリング**: 複雑になった比較ロジックを読みやすくする。

### ステップ9: プレリリース識別子を持つバージョンの表示
- [ ] **テスト**: `"1.0.0-alpha.1"`をパースし、再度文字列化したときに元に戻ることを確認するテストを追加する。
- [ ] **実装**: `Display`トレイトの実装を修正し、プレリリース部分も正しく出力できるようにする。
- [ ] **リファクタリング**: 文字列生成ロジックを整理する。

## フェーズ4: ビルドメタデータのサポート

### ステップ10: ビルドメタデータを持つバージョンのパース
- [ ] **構造体変更**: `Version`構造体にビルドメタデータを格納するフィールドを追加する。
  ```rust
  // 例
  build: Vec<String>,
  ```
- [ ] **テスト**: `"1.0.0+build.1"`, `"1.0.0-alpha+build.123"`のような文字列をパースできるテス��を書く。
- [ ] **実装**: `FromStr`の実装を拡張し、`+`以降のビルドメタデータ部分をパースできるようにする。
- [ ] **リファクタリング**: パースロジックを整理する。

### ステップ11: ビルドメタデータを持つバージョンの比較
- [ ] **テスト**: ビルドメタデータはバージョンの優先順位に影響を与えないことを確認するテストを追加する。
  - `Version::from_str("1.0.0+build.1").unwrap() == Version::from_str("1.0.0+build.2").unwrap()` (順序比較において)
  - `assert_eq!(Version::from_str("1.0.0+build.1").unwrap().cmp(&Version::from_str("1.0.0+build.2").unwrap()), std::cmp::Ordering::Equal)`
- [ ] **実装**: `Ord`と`PartialEq`の実装で、ビルドメタデータが無視されるようにする。
- [ ] **リファクタリング**: 変更は不要なはずだが、意図が明確になるようにコードを確認する。

### ステップ12: ビルドメタデータを持つバージョンの表示
- [ ] **テスト**: `"1.0.0+build.1"`をパースし、再度文字列化したときに元に戻ることを確認するテストを追加する。
- [ ] **実装**: `Display`トレイトの実装を修正し、ビルドメタデータ部分も正しく出力できるようにする��
- [ ] **リファクタリング**: 文字列生成ロジックを整理する。
